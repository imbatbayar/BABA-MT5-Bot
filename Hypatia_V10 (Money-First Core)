//+------------------------------------------------------------------+
//|                      Hypatia_V10 (Money-First Core)              |
//|  Risk-first engine: Rule-of-Stop, RR>=1 gate, Journal, Guards   |
//|  Base logic: SmartTrend(H4/H1) + Breakout→Retest + Range + PB   |
//+------------------------------------------------------------------+
#property strict

//======================== Inputs ===================================
//--- General
input ENUM_TIMEFRAMES InpTF        = PERIOD_H1;    // Entry TF
input int             InpMagic     = 900119;       // Magic
input bool            InpLongs     = true;
input bool            InpShorts    = true;
input bool            InpDebugLogs = true;
input bool            InpDrawHUD   = true;

//--- Trend / ATR / EMA
input ENUM_TIMEFRAMES InpTFTrend   = PERIOD_H4;    // Macro TF
input int             InpEMA       = 200;          // Macro EMA
input ENUM_TIMEFRAMES InpTFMicro   = PERIOD_H1;    // Micro TF
input int             InpEMAMicro  = 50;           // Micro EMA
input int             InpATR       = 14;

//--- Breakout + Retest
input int    InpSRLookback        = 80;
input int    InpMinTouches        = 2;
input double InpConfirmBodyPct    = 40.0;
input double InpBreakBuffATR      = 0.30;
input double InpRetestTolATR      = 0.50;
input double InpRetestWickMinPct  = 30.0;
input int    InpRetestTTLBars     = 12;
input int    InpFalseBreakWindow  = 2;
input bool   InpEnableCounterFB   = true;  // Fakeout эсрэг орох

//--- Range / Indecision
input bool   InpEnableRangeMode       = true;
input int    InpRangeLookback         = 60;
input double InpRangeMinWidthATR      = 0.8;
input double InpRangeSlopeATRPerBar   = 0.10;
input int    InpRangeMinTouches       = 2;
input double InpRangeTouchTolATR      = 0.30;
input bool   InpRangeIgnoreEMA        = true;

input bool   InpSkipIndecision        = false; // OFF by default
input int    InpIndecN                = 5;
input double InpIndecBodyPctMax       = 28.0;
input double InpIndecRangeATR         = 0.55;

//--- Pullback continuation (Micro EMA50)
input double InpPB_NearEMAAtr         = 0.30;
input double InpPB_WickMinPct         = 28.0;

//--- Dynamic Risk
input bool   InpUseDynamicRisk        = true;
input double InpRiskPct               = 0.50;  // fallback risk if dynamic off
input double InpRiskTrendPct          = 0.50;
input double InpRiskRangePct          = 0.20;
input double InpRiskCounterPct        = 0.15;

//--- Position mgmt
input bool   InpUseTP1_BE_Trail       = true;
input double InpRR_TP1                = 1.0;
input double InpTrailATRmult          = 1.5;
input int    InpTimeStopBars          = 8;     // N барт >=0.3R хүрээгүй бол хаа
input double InpTimeStopMinRR         = 0.30;

//--- Guards
input double InpMaxSpreadPts          = 25;    // 2.5 пип (5-digit)
input double InpATRSpikeRatio         = 2.2;   // cur ATR > ratio * MA(ATR)
input int    InpATRAvgPeriod          = 50;
input int    InpMaxDeviation          = 30;    // requote хамгаалалт (points)
input bool   InpStrictTrendMatch      = false; // Macro&&Micro эсэх

//--- Cooldown / Drawdown Caps (equity-based)
input int    InpCooldownBars          = 6;
input int    InpCooldownMinutes       = 0;
input double InpMaxDDDay              = 3.0;   // % of day start equity
input double InpMaxDDMon              = 15.0;  // % of month start equity

//=== NEW: Rule-of-Stop / Control ====================================
input double InpDailyRStop            = 2.0;   // өдөрт -2R -> STOP
input double InpWeeklyDDLimit         = 6.0;   // % equity (week anchor)
input int    InpMaxConsecLoss         = 3;     // дараалсан алдагдал
input int    InpMaxActiveTrades       = 1;     // нэг үеийн нээлттэй позиц

//=== NEW: Journal / News =============================================
input bool   InpJournalCSV            = true;
input string InpJournalFile           = "HypatiaV10_Journal.csv";
input bool   InpNewsPause             = false;
input int    InpNewsBeforeMin         = 30;
input int    InpNewsAfterMin          = 30;

//======================== Globals ====================================
double   g_point, g_tickvalue, g_ticksize;
int      g_digits;

datetime g_prevBarTime = 0;
datetime g_lastLossTime= 0;
int      g_lastLossBar = -1;

double   g_dayStartEquity  = 0.0;
double   g_monthStartEquity= 0.0;
int      g_dayCached       = -1;
int      g_monthCached     = -1;

// week anchor
int      g_weekCached      = -1;   // coarse week index (day_of_year/7)
double   g_weekStartEquity = 0.0;

// breakout-retest state
bool   g_waitRetest = false;
bool   g_breakUp    = false;
double g_breakLevel = 0.0;
int    g_breakBar   = -1;

// risk override (dynamic tier)
double  g_riskOverridePct = -1.0;

//=== NEW: R accounting (for Rule-of-Stop & Journal)
double  g_dayR = 0.0;              // cumulative R of the day
int     g_consecLoss = 0;

// track current position baseline for R calc (netting: 1 position)
ulong   g_currTicket = 0;
double  g_currRiskPts = 0.0;
double  g_currEntry   = 0.0;
double  g_currInitVol = 0.0;
double  g_currMoneyRisk = 0.0;     // USD at open for full position
int     g_currDir = 0;             // 1 buy, -1 sell

// ==== Forward declarations (compile fix) ====
bool DrawdownExceeded();
bool CooldownActive();
bool IsIndecisionZone();
bool SpreadTooWide();
bool ATRSpike();
int  OpenCountByMagic();


//======================== Helpers / IO ===============================
int    DigitsSym(){ return (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS); }
double PointSym(){  return SymbolInfoDouble(_Symbol, SYMBOL_POINT); }
double NormalizePrice(double p){ return NormalizeDouble(p, DigitsSym()); }

ENUM_ORDER_TYPE_FILLING PickFilling()
{
   long mask = SymbolInfoInteger(_Symbol, SYMBOL_FILLING_MODE);
   if( (mask & ORDER_FILLING_IOC) != 0 ) return ORDER_FILLING_IOC;
   if( (mask & ORDER_FILLING_FOK) != 0 ) return ORDER_FILLING_FOK;
   return ORDER_FILLING_IOC;
}

bool PrepareVolume(double &vol)
{
   double minv = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double maxv = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   vol = MathMax(minv, MathMin(maxv, vol));
   vol = MathRound(vol/step)*step;
   return (vol>=minv-1e-9 && vol<=maxv+1e-9);
}
double MinStopDistPts()
{
   long stop_level   = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   long freeze_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_FREEZE_LEVEL);
   return (double)MathMax(stop_level, freeze_level);
}
void ClampStops(ENUM_ORDER_TYPE type,double price,double &sl,double &tp)
{
   double mindPts = MinStopDistPts();
   if(type==ORDER_TYPE_BUY)
   {
      if(sl>0 && ((price - sl)/PointSym()) < mindPts) sl = price - mindPts*PointSym();
      if(tp>0 && ((tp - price)/PointSym()) < mindPts) tp = price + mindPts*PointSym();
   }
   else
   {
      if(sl>0 && ((sl - price)/PointSym()) < mindPts) sl = price + mindPts*PointSym();
      if(tp>0 && ((price - tp)/PointSym()) < mindPts) tp = price - mindPts*PointSym();
   }
   if(sl>0) sl = NormalizePrice(sl);
   if(tp>0) tp = NormalizePrice(tp);
}
bool SpreadTooWide()
{
   double spr = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID))/PointSym();
   if(spr > InpMaxSpreadPts)
   {
      if(InpDebugLogs && NewBar())
         PrintFormat("[V10-Guard] Spread=%.1fpts > limit=%.1fpts → skip", spr, InpMaxSpreadPts);
      return true;
   }
   return false;
}
bool ATRSpike()
{
   int p = MathMax(10, InpATRAvgPeriod);
   int h=iATR(_Symbol, InpTF, InpATR); if(h==INVALID_HANDLE) return false;
   double a[64]; int n=CopyBuffer(h,0,0,p+1,a); if(n<p+1) return false;
   double cur=a[0];
   double sum=0; for(int i=1;i<=p;i++) sum+=a[i];
   double avg=sum/p;
   if(avg<=0) return false;
   bool spike = (cur > avg*InpATRSpikeRatio);
   if(spike && InpDebugLogs && NewBar())
      PrintFormat("[V10-Guard] ATR spike: cur=%.1f > avg*%.2f(%.1f) → skip", cur/PointSym(), InpATRSpikeRatio, (avg/PointSym()));
   return spike;
}

bool SendDeal(ENUM_ORDER_TYPE type, double vol, double &price, double &sl, double &tp, string tag, int deviation)
{
   if(!PrepareVolume(vol)){ if(InpDebugLogs) Print("[V10-IO] Volume invalid"); return false; }

   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   price = (type==ORDER_TYPE_BUY ? ask : bid);

   ClampStops(type, price, sl, tp);

   MqlTradeRequest  r;  MqlTradeResult s;  ZeroMemory(r); ZeroMemory(s);
   r.action       = TRADE_ACTION_DEAL;
   r.symbol       = _Symbol;
   r.magic        = InpMagic;
   r.type         = type;
   r.type_filling = PickFilling();
   r.deviation    = deviation;
   r.volume       = vol;
   r.price        = price;
   r.sl           = sl;
   r.tp           = tp;
   r.comment      = tag;

   bool ok = OrderSend(r, s);

   if(!ok && (s.retcode==TRADE_RETCODE_INVALID_FILL || s.retcode==10030))
   {
      r.type_filling = (r.type_filling==ORDER_FILLING_IOC) ? ORDER_FILLING_FOK : ORDER_FILLING_IOC;
      ok = OrderSend(r, s);
   }

   if(InpDebugLogs)
      PrintFormat("[V10-IO] %s vol=%.2f ok=%s ret=%d cmt=%s  px=%.5f sl=%.5f tp=%.5f fill=%d",
         EnumToString(type), vol, ok?"T":"F", s.retcode, s.comment, r.price, r.sl, r.tp, r.type_filling);

   return (s.retcode==TRADE_RETCODE_DONE || s.retcode==TRADE_RETCODE_PLACED);
}
bool SendSLTP(double sl,double tp)
{
   MqlTradeRequest r; MqlTradeResult s; ZeroMemory(r); ZeroMemory(s);
   r.action=TRADE_ACTION_SLTP; r.symbol=_Symbol; r.magic=InpMagic; r.sl=sl; r.tp=tp;
   bool ok=OrderSend(r,s);
   if(InpDebugLogs && !ok) PrintFormat("[V10-IO] SLTP fail ret=%d comment=%s", s.retcode, s.comment);
   return ok && (s.retcode==TRADE_RETCODE_DONE);
}

//======================== Utilities ==================================
double PipsToPrice(double pips){ return pips * g_point; }
bool NewBar()
{
   datetime t=iTime(_Symbol, InpTF, 0);
   if(t!=g_prevBarTime){ g_prevBarTime=t; return true; }
   return false;
}
void HUD(string s)
{
   if(!InpDrawHUD) return;
   string name="HypaV10HUD";
   if(ObjectFind(0,name)<0) ObjectCreate(0,name,OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,name,OBJPROP_CORNER,CORNER_RIGHT_UPPER);
   ObjectSetInteger(0,name,OBJPROP_XDISTANCE,12);
   ObjectSetInteger(0,name,OBJPROP_YDISTANCE,18);
   ObjectSetInteger(0,name,OBJPROP_FONTSIZE,8);
   ObjectSetString(0,name,OBJPROP_TEXT,s);
}
void DrawLiveSignal(bool isBuy,double price)
{
   const string nm="V10SIG_CURR";
   ObjectDelete(0,nm);
   ObjectCreate(0, nm, OBJ_ARROW, 0, iTime(_Symbol, PERIOD_CURRENT, 0), price);
   ObjectSetInteger(0,nm,OBJPROP_ARROWCODE, isBuy?241:242);
   ObjectSetInteger(0,nm,OBJPROP_WIDTH,2);
}

//======================== Indicators =================================
double EMA(ENUM_TIMEFRAMES tf, int period, int shift=0)
{
   int h=iMA(_Symbol, tf, period, 0, MODE_EMA, PRICE_CLOSE);
   if(h==INVALID_HANDLE) return 0.0;
   double b[]; if(CopyBuffer(h,0,shift,1,b)<1) return 0.0;
   return b[0];
}
double ATRpts(ENUM_TIMEFRAMES tf, int period, int shift=0)
{
   int h=iATR(_Symbol, tf, period);
   if(h==INVALID_HANDLE) return 0.0;
   double b[]; if(CopyBuffer(h,0,shift,1,b)<1) return 0.0;
   return b[0]/_Point;
}
double BodyPctTF(ENUM_TIMEFRAMES tf, int shift)
{
   MqlRates r[]; if(CopyRates(_Symbol, tf, shift, 2, r)<2) return 0.0;
   double body=MathAbs(r[0].close-r[0].open), range=(r[0].high-r[0].low);
   if(range<=0) return 0.0;
   return (body/range)*100.0;
}

//======================== Trend logic =================================
bool MacroTrendUp()   { return SymbolInfoDouble(_Symbol,SYMBOL_BID) > EMA(InpTFTrend, InpEMA, 0); }
bool MacroTrendDown() { return SymbolInfoDouble(_Symbol,SYMBOL_ASK) < EMA(InpTFTrend, InpEMA, 0); }
bool MicroTrendUp()   { return iClose(_Symbol, InpTFMicro, 0)      > EMA(InpTFMicro, InpEMAMicro, 0); }
bool MicroTrendDown() { return iClose(_Symbol, InpTFMicro, 0)      < EMA(InpTFMicro, InpEMAMicro, 0); }
bool TrendUp(){   return InpStrictTrendMatch ? (MacroTrendUp() && MicroTrendUp())   : MacroTrendUp(); }
bool TrendDown(){ return InpStrictTrendMatch ? (MacroTrendDown() && MicroTrendDown()) : MacroTrendDown(); }

//======================== Levels / Range ==============================
bool DonchianLevels(int len, double &upper, double &lower)
{
   upper=0; lower=0;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, len+2, r)<len) return false;
   double hi=r[1].high, lo=r[1].low;
   for(int i=1;i<=len;i++){ hi=MathMax(hi, r[i].high); lo=MathMin(lo, r[i].low); }
   upper=hi; lower=lo; return (upper>lower);
}
bool FindLevelUp(double &level_price, int &touches)
{
   level_price=0.0; touches=0;
   int need=InpSRLookback+5;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, need, r)<need/2) return false;

   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   double tol_pts=atrp*0.25;

   double cand[256]; int csz=0; int n=ArraySize(r);
   for(int i=1;i<n-1 && csz<256;i++)
      if(r[i].high>r[i-1].high && r[i].high>r[i+1].high)
         cand[csz++]=r[i].high/_Point;
   if(csz==0) return false;

   int bestTouch=0; double bestLvl=0.0;
   for(int k=0;k<csz;k++){
      double lvl=cand[k]; int t=0;
      for(int j=1;j<n;j++)
         if(MathAbs((r[j].high/_Point)-lvl)<=tol_pts) t++;
      if(t>=InpMinTouches && (t>bestTouch || (t==bestTouch && lvl>bestLvl)))
      { bestTouch=t; bestLvl=lvl; }
   }
   if(bestTouch<InpMinTouches) return false;
   level_price=bestLvl*_Point; touches=bestTouch; return true;
}
bool FindLevelDown(double &level_price, int &touches)
{
   level_price=0.0; touches=0;
   int need=InpSRLookback+5;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, need, r)<need/2) return false;

   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   double tol_pts=atrp*0.25;

   double cand[256]; int csz=0; int n=ArraySize(r);
   for(int i=1;i<n-1 && csz<256;i++)
      if(r[i].low<r[i-1].low && r[i].low<r[i+1].low)
         cand[csz++]=r[i].low/_Point;
   if(csz==0) return false;

   int bestTouch=0; double bestLvl=0.0;
   for(int k=0;k<csz;k++){
      double lvl=cand[k]; int t=0;
      for(int j=1;j<n;j++)
         if(MathAbs((r[j].low/_Point)-lvl)<=tol_pts) t++;
      if(t>=InpMinTouches && (t>bestTouch || (t==bestTouch && lvl<bestLvl)))
      { bestTouch=t; bestLvl=lvl; }
   }
   if(bestTouch<InpMinTouches) return false;
   level_price=bestLvl*_Point; touches=bestTouch; return true;
}

//======================== Breakout / Retest / FalseBreak =============
bool BreakoutUp_Q(int &breakShift, double &level_price)
{
   int touch=0;
   bool ok=FindLevelUp(level_price, touch);
   if(!ok){
      double u,l; if(!DonchianLevels(InpSRLookback,u,l)) return false;
      level_price=u;
   }
   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   MqlRates rr[]; if(CopyRates(_Symbol, InpTF, 0, 1, rr)<1) return false;
   double close0=rr[0].close;
   if(BodyPctTF(InpTF,0) < InpConfirmBodyPct) return false;
   if( (close0 - level_price) < PipsToPrice(atrp*InpBreakBuffATR) ) return false;
   breakShift=0; return true;
}
bool BreakoutDown_Q(int &breakShift, double &level_price)
{
   int touch=0;
   bool ok=FindLevelDown(level_price, touch);
   if(!ok){
      double u,l; if(!DonchianLevels(InpSRLookback,u,l)) return false;
      level_price=l;
   }
   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   MqlRates rr[]; if(CopyRates(_Symbol, InpTF, 0, 1, rr)<1) return false;
   double close0=rr[0].close;
   if(BodyPctTF(InpTF,0) < InpConfirmBodyPct) return false;
   if( (level_price - close0) < PipsToPrice(atrp*InpBreakBuffATR) ) return false;
   breakShift=0; return true;
}
bool RetestReadyNow(bool up, double level_price,
                    double &entryPrice, double &slPrice, double &slPts)
{
   double atrp = ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   double tol  = atrp*InpRetestTolATR;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, 2, r)<2) return false;

   double h=r[0].high, l=r[0].low, o=r[0].open, c=r[0].close;
   bool touched = up ? (MathAbs((level_price/_Point)-(l/_Point))<=tol)
                     : (MathAbs((level_price/_Point)-(h/_Point))<=tol);
   double range=h-l; if(range<=0) return false;
   double upperW=h-MathMax(o,c), lowerW=MathMin(o,c)-l;
   double wickPct = (up ? (lowerW/range) : (upperW/range))*100.0;
   bool dirOK   = up ? (c>=o) : (c<=o);

   if(!(touched && dirOK && wickPct>=InpRetestWickMinPct)) return false;

   if(up){ entryPrice=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
           slPts=atrp*1.2; slPrice=entryPrice-PipsToPrice(slPts); }
   else  { entryPrice=SymbolInfoDouble(_Symbol,SYMBOL_BID);
           slPts=atrp*1.2; slPrice=entryPrice+PipsToPrice(slPts); }
   return true;
}
bool DetectFalseBreak(bool up, double level, int window)
{
   for(int i=1;i<=window;i++){
      double c=iClose(_Symbol, InpTF, i);
      if(up && c<level)  return true;
      if(!up && c>level) return true;
   }
   return false;
}

//======================== Range Entries ===============================
bool DetectRange(double &upper, double &lower, int &touchUp, int &touchDn)
{
   upper=0.0; lower=0.0; touchUp=0; touchDn=0;
   int need = InpRangeLookback + 5;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, need, r) < InpRangeLookback) return false;
   double atrp = ATRpts(InpTF, InpATR); if(atrp<=0) return false;

   double hi=r[1].high, lo=r[1].low;
   for(int i=1;i<=InpRangeLookback;i++){ hi=MathMax(hi, r[i].high); lo=MathMin(lo, r[i].low); }

   double widthPts = (hi - lo)/_Point;
   if(widthPts < atrp*InpRangeMinWidthATR) return false;

   double slopePtsPerBar = MathAbs((r[0].close - r[InpRangeLookback].close)/_Point) / InpRangeLookback;
   if(slopePtsPerBar > atrp*InpRangeSlopeATRPerBar) return false;

   double tol = atrp*InpRangeTouchTolATR;
   for(int i=1;i<=InpRangeLookback;i++)
   {
      if(MathAbs((r[i].high/_Point) - (hi/_Point)) <= tol) touchUp++;
      if(MathAbs((r[i].low/_Point)  - (lo/_Point))  <= tol) touchDn++;
   }
   if(touchUp < InpRangeMinTouches || touchDn < InpRangeMinTouches) return false;

   upper = hi; lower = lo; return true;
}
bool RangeSignalBuy(double upper, double lower, double atr_pts,
                    double &entryPrice, double &slPrice, double &slPts)
{
   double tol = atr_pts*InpRangeTouchTolATR;
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if( ((price/_Point) - (lower/_Point)) > tol ) return false;

   double bodyPct = BodyPctTF(InpTF, 0);
   if(bodyPct < 18.0) return false;

   entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   slPts  = atr_pts*1.0;
   slPrice= entryPrice - PipsToPrice(slPts);
   return true;
}
bool RangeSignalSell(double upper, double lower, double atr_pts,
                     double &entryPrice, double &slPrice, double &slPts)
{
   double tol = atr_pts*InpRangeTouchTolATR;
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   if( ((upper/_Point) - (price/_Point)) > tol ) return false;

   double bodyPct = BodyPctTF(InpTF, 0);
   if(bodyPct < 18.0) return false;

   entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   slPts  = atr_pts*1.0;
   slPrice= entryPrice + PipsToPrice(slPts);
   return true;
}

//======================== Risk / Lots =================================
void SetRiskOnce(double pct){ g_riskOverridePct = pct; }
double PickRisk(bool trendMode, bool counterMode=false)
{
   if(!InpUseDynamicRisk) return InpRiskPct;
   if(counterMode) return InpRiskCounterPct;
   return (trendMode ? InpRiskTrendPct : InpRiskRangePct);
}
double LotsForRisk(double sl_points, double &outMoneyRiskUSD)
{
   outMoneyRiskUSD = 0.0;
   if(sl_points<=0.0) return 0.0;

   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double usePct = (g_riskOverridePct>0.0 ? g_riskOverridePct : InpRiskPct);
   double riskUSD= equity*(usePct/100.0);

   double tickVal  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double point    = PointSym();

   double usdPerPoint = (tickSize>0 ? tickVal / (tickSize/point) : 0.0);
   if(usdPerPoint<=0) return 0.0;

   double lots = riskUSD / (sl_points * usdPerPoint);

   double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minL = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxL = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   lots = MathFloor(lots/step)*step;
   lots = MathMax(minL, MathMin(maxL, lots));

   g_riskOverridePct = -1.0;
   outMoneyRiskUSD = riskUSD;
   return lots;
}

//======================== Journal =====================================
int  JOpen()
{
   int f = FileOpen(InpJournalFile, FILE_CSV|FILE_READ|FILE_WRITE|FILE_COMMON, ';');
   if(f!=INVALID_HANDLE)
   {
      if(FileSize(f)==0)
      {
         FileWrite(f,"time","symbol","phase","dir","entry","sl","tp","lots","riskPts","moneyRisk","profit","R","note");
      }
      FileSeek(f,0,SEEK_END);
   }
   return f;
}
void JWrite(string phase, int dir, double entry, double sl, double tp, double lots,
            double riskPts, double moneyRisk, double profit, double R, string note="")
{
   if(!InpJournalCSV) return;
   int f=JOpen(); if(f==INVALID_HANDLE) return;
   string ts=TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES|TIME_SECONDS);
   FileWrite(f, ts, _Symbol, phase, IntegerToString(dir), DoubleToString(entry, DigitsSym()),
             DoubleToString(sl,DigitsSym()), DoubleToString(tp,DigitsSym()),
             DoubleToString(lots,2), DoubleToString(riskPts,1), DoubleToString(moneyRisk,2),
             DoubleToString(profit,2), DoubleToString(R,3), note);
   FileClose(f);
}

//======================== Position Mgmt ===============================
bool HasOpenPositionDir(int dir)
{
   if(!PositionSelect(_Symbol)) return false;
   if(PositionGetInteger(POSITION_MAGIC)!=InpMagic) return false;
   long type=PositionGetInteger(POSITION_TYPE);
   if(dir==1  && type==POSITION_TYPE_BUY ) return true;
   if(dir==-1 && type==POSITION_TYPE_SELL) return true;
   return false;
}
// NEW — netting-safe хувилбар (энэ символ дээр энэ magic-тэй нээлттэй эсэх)
int OpenCountByMagic()
{
   if(PositionSelect(_Symbol))
   {
      if(PositionGetInteger(POSITION_MAGIC)==InpMagic)
         return 1;
   }
   return 0;
}

//=== NEW: RR gate (>=1.0R)
bool RRGate_OK(double rr_tp1){ return (rr_tp1 >= 1.0 - 1e-9); }

//=== NEW: Trade block checker (Rule-of-Stop, DD, cooldown, news, active trades)
bool IsTradeBlocked()
{
   // Active trades cap
   if(InpMaxActiveTrades>0 && OpenCountByMagic()>=InpMaxActiveTrades) return true;

   // Day/Month equity DD caps (existing)
   if(SpreadTooWide() || ATRSpike()) return true;
   if(DrawdownExceeded()) return true;
   if(CooldownActive()) return true;
   if(InpNewsPause && /* TODO: IsNewsNow() */ false) return true;

   // Daily R stop
   if(InpDailyRStop>0.0 && g_dayR <= -InpDailyRStop) { if(InpDebugLogs && NewBar()) Print("[V10-Rule] Daily -R limit hit"); return true; }

   // Weekly DD
   if(g_weekStartEquity>0 && InpWeeklyDDLimit>0)
   {
      double eq=AccountInfoDouble(ACCOUNT_EQUITY);
      double dd=(g_weekStartEquity - eq)*100.0/g_weekStartEquity;
      if(dd >= InpWeeklyDDLimit){ if(InpDebugLogs && NewBar()) Print("[V10-Rule] Weekly DD limit hit"); return true; }
   }

   // Consec loss
   if(InpMaxConsecLoss>0 && g_consecLoss>=InpMaxConsecLoss){ if(InpDebugLogs && NewBar()) Print("[V10-Rule] ConsecLoss limit"); return true; }

   return false;
}

bool OpenPosition(int dir, double entry, double sl, double tp)
{
   if(IsTradeBlocked()) return false;

   double slPts = MathAbs((entry - sl)/g_point);
   // RR gate (TP1 = 1.0R бага бол хориглох). Хэрэв TP яг BE-тэй явбал rr_tp1=InpRR_TP1.
   if(!RRGate_OK(InpRR_TP1)) { if(InpDebugLogs) Print("[V10] RR<1.0 gate -> skip"); return false; }

   double moneyRisk=0.0;
   double lots  = LotsForRisk(slPts, moneyRisk);
   if(lots<=0){ if(InpDebugLogs) Print("[V10] Lots<=0 -> skip"); return false; }

   ENUM_ORDER_TYPE t = (dir==1 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL);
   double px=0.0; double slx=sl; double tpx=tp;
   bool ok = SendDeal(t, lots, px, slx, tpx, "V10", InpMaxDeviation);
   if(!ok && InpDebugLogs)
      PrintFormat("[V10] Order rejected. dir=%d lots=%.2f sl=%.5f tp=%.5f", dir, lots, sl, tp);

   if(ok)
   {
      DrawLiveSignal(dir==1, px);
      // track baseline for R accounting
      if(PositionSelect(_Symbol) && PositionGetInteger(POSITION_MAGIC)==InpMagic)
      {
         g_currTicket   = (ulong)PositionGetInteger(POSITION_TICKET);
         g_currEntry    = PositionGetDouble(POSITION_PRICE_OPEN);
         g_currInitVol  = PositionGetDouble(POSITION_VOLUME);
         g_currRiskPts  = MathAbs((g_currEntry - PositionGetDouble(POSITION_SL))/g_point);
         g_currMoneyRisk= moneyRisk;
         g_currDir      = dir;
      }
      JWrite("OPEN", dir, px, slx, tpx, lots, slPts, moneyRisk, 0.0, 0.0, "");
   }
   return ok;
}

bool ClosePartial(ulong ticket, double frac)
{
   if(!PositionSelectByTicket(ticket)) PositionSelect(_Symbol);
   if(!PositionSelect(_Symbol)) return false;

   double vol=PositionGetDouble(POSITION_VOLUME);
   double step=SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double part=MathFloor(vol*frac/step)*step;
   if(part<=0) return false;

   long posType=PositionGetInteger(POSITION_TYPE);
   ENUM_ORDER_TYPE ot=(posType==POSITION_TYPE_BUY)? ORDER_TYPE_SELL:ORDER_TYPE_BUY;

   double px=0, sl=0, tp=0;
   bool ok = SendDeal(ot, part, px, sl, tp, "V10-Partial", InpMaxDeviation);
   if(!ok) Print("[V10] Partial close failed");
   else    JWrite("PARTIAL", (posType==POSITION_TYPE_BUY)?1:-1, px, 0, 0, part, g_currRiskPts, 0.0, 0.0, 0.0, "");
   return ok;
}
bool MoveSLtoBE(ulong ticket, double entry_price)
{
   if(!PositionSelectByTicket(ticket)) PositionSelect(_Symbol);
   if(!PositionSelect(_Symbol)) return false;

   long type=PositionGetInteger(POSITION_TYPE);
   double curSL=PositionGetDouble(POSITION_SL);
   double be=NormalizePrice(entry_price);
   if(curSL==0 || (type==POSITION_TYPE_BUY && curSL<be) || (type==POSITION_TYPE_SELL && curSL>be))
   {
      double tp=PositionGetDouble(POSITION_TP);
      bool ok=SendSLTP(be, tp);
      if(ok) JWrite("BE", (type==POSITION_TYPE_BUY)?1:-1, entry_price, be, tp, PositionGetDouble(POSITION_VOLUME), g_currRiskPts, 0.0, 0.0, 0.0, "");
      return ok;
   }
   return true;
}
bool UpdateATRTrail(ulong ticket, double atr_pts, double entry)
{
   if(!PositionSelectByTicket(ticket)) PositionSelect(_Symbol);
   if(!PositionSelect(_Symbol)) return false;

   long type=PositionGetInteger(POSITION_TYPE);
   double price=(type==POSITION_TYPE_BUY)? SymbolInfoDouble(_Symbol,SYMBOL_BID)
                                         : SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double trailPts=atr_pts*InpTrailATRmult;
   double newSL = (type==POSITION_TYPE_BUY)
                    ? price - trailPts*PointSym()
                    : price + trailPts*PointSym();
   newSL = NormalizePrice(newSL);

   double curSL=PositionGetDouble(POSITION_SL);
   if( (type==POSITION_TYPE_BUY && newSL>curSL) ||
       (type==POSITION_TYPE_SELL&& newSL<curSL) )
   {
      double tp=PositionGetDouble(POSITION_TP);
      bool ok=SendSLTP(newSL, tp);
      if(ok) JWrite("TRAIL", (type==POSITION_TYPE_BUY)?1:-1, entry, newSL, tp, PositionGetDouble(POSITION_VOLUME), g_currRiskPts, 0.0, 0.0, 0.0, "");
      return ok;
   }
   return true;
}
void ManageOpenPositions()
{
   if(!InpUseTP1_BE_Trail) return;
   if(!PositionSelect(_Symbol)) return;
   if(PositionGetInteger(POSITION_MAGIC)!=InpMagic) return;

   ulong  t    =(ulong)PositionGetInteger(POSITION_TICKET);
   long   type =PositionGetInteger(POSITION_TYPE);
   double entry=PositionGetDouble(POSITION_PRICE_OPEN);
   double sl   =PositionGetDouble(POSITION_SL);

   double priceBid=SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double priceAsk=SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double price=(type==POSITION_TYPE_BUY)? priceBid:priceAsk;

   double riskPts=MathAbs((entry-sl)/g_point);
   if(riskPts<=0) return;

   // TP1 → 50% close + BE
   double rrNowPts = (type==POSITION_TYPE_BUY)? (price-entry)/g_point : (entry-price)/g_point;
   if(rrNowPts >= (InpRR_TP1 * riskPts))
   { ClosePartial(t, 0.5); MoveSLtoBE(t, entry); }

   // ATR Trailing
   double atrp=ATRpts(InpTF, InpATR);
   UpdateATRTrail(t, atrp, entry);

   // Time-Stop: N барт дор хаяж 0.3R явж чадахгүй бол гар
   if(InpTimeStopBars>0)
   {
      datetime tOpen=(datetime)PositionGetInteger(POSITION_TIME);
      int shOpen = iBarShift(_Symbol, InpTF, tOpen, true);
      int shNow  = iBarShift(_Symbol, InpTF, TimeCurrent(), true);
      int elapsed = shNow - shOpen;   // нээгдсэнээс хойш хэдэн бар өнгөрсөн

      if(elapsed >= InpTimeStopBars && rrNowPts < (InpTimeStopMinRR*riskPts))
      {
         ENUM_ORDER_TYPE ot=(type==POSITION_TYPE_BUY)? ORDER_TYPE_SELL:ORDER_TYPE_BUY;
         double px=0, slx=0, tpx=0;
         if(SendDeal(ot, PositionGetDouble(POSITION_VOLUME), px, slx, tpx, "V10-TimeStop", InpMaxDeviation))
            JWrite("TIMESTOP_EXIT", (type==POSITION_TYPE_BUY)?1:-1, px, 0, 0, PositionGetDouble(POSITION_VOLUME), riskPts, 0.0, 0.0, 0.0, "");
      }
   }
}

//======================== Indecision / Cooldown / DD ==================
bool IsIndecisionZone()
{
   if(!InpSkipIndecision) return false;
   double atrp = ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   int n = MathMax(3, InpIndecN);
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, n, r) < n) return false;
   int smallCnt = 0;
   for(int i=0;i<n;i++)
   {
      double body = MathAbs(r[i].close - r[i].open);
      double range= (r[i].high  - r[i].low);
      double bodyPct = (range>0 ? (body/range)*100.0 : 0.0);
      bool smallBody = (bodyPct <= InpIndecBodyPctMax);
      bool smallRange= ((range/_Point) <= atrp*InpIndecRangeATR);
      if(smallBody && smallRange) smallCnt++;
   }
   return (smallCnt >= (n*3)/5);
}
bool CooldownActive()
{
   bool useBars=(InpCooldownBars>0), useMins=(InpCooldownMinutes>0);
   if(!useBars && !useMins) return false;

   if(useBars && g_lastLossBar>=0)
   {
      int barsNow=iBars(_Symbol, InpTF);
      if(barsNow - g_lastLossBar < InpCooldownBars) return true;
   }
   if(useMins && g_lastLossTime>0)
   {
      datetime now=TimeCurrent();
      if((now-g_lastLossTime) < (InpCooldownMinutes*60)) return true;
   }
   return false;
}
void RefreshEquityAnchors()
{
   MqlDateTime tm; TimeToStruct(TimeCurrent(), tm);

   if(g_dayCached!=tm.day)
   {
      g_dayCached=tm.day;
      g_dayStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
      g_dayR = 0.0; g_consecLoss=0; // шинэ өдөр → R reset
      if(InpDebugLogs) PrintFormat("[V10] Day anchor set: %.2f", g_dayStartEquity);
   }
   if(g_monthCached!=tm.mon)
   {
      g_monthCached=tm.mon;
      g_monthStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
      if(InpDebugLogs) PrintFormat("[V10] Month anchor set: %.2f", g_monthStartEquity);
   }

   int wk = tm.day_of_year/7;
   if(g_weekCached!=wk)
   {
      g_weekCached=wk;
      g_weekStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
      if(InpDebugLogs) PrintFormat("[V10] Week anchor set: %.2f", g_weekStartEquity);
   }
}
bool DrawdownExceeded()
{
   RefreshEquityAnchors();
   double eq = AccountInfoDouble(ACCOUNT_EQUITY);
   bool stop=false;

   if(g_dayStartEquity>0 && InpMaxDDDay>0)
   {
      double dd = (g_dayStartEquity - eq)*100.0 / g_dayStartEquity;
      if(dd >= InpMaxDDDay){ if(InpDebugLogs && NewBar()) Print("[V10-Guard] Day DD limit hit → pause"); stop=true; }
   }
   if(g_monthStartEquity>0 && InpMaxDDMon>0)
   {
      double ddm = (g_monthStartEquity - eq)*100.0 / g_monthStartEquity;
      if(ddm >= InpMaxDDMon){ if(InpDebugLogs && NewBar()) Print("[V10-Guard] Month DD limit hit → pause"); stop=true; }
   }
   return stop;
}

//======================== Lifecycle ==================================
int OnInit()
{
   g_point     = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   g_tickvalue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   g_ticksize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   g_digits    = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);

   g_lastLossTime = 0;
   g_lastLossBar  = -1;

   g_dayCached = -1; g_monthCached = -1; g_weekCached=-1;
   RefreshEquityAnchors();

   g_currTicket=0; g_currRiskPts=0.0; g_currEntry=0.0; g_currInitVol=0.0; g_currMoneyRisk=0.0; g_currDir=0;

   Print("Hypatia_V10 init OK");
   return(INIT_SUCCEEDED);
}
void OnDeinit(const int reason){ Print("Hypatia_V10 deinit. reason=", reason); }

//=== R accounting from deals
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(trans.type!=TRADE_TRANSACTION_DEAL_ADD) return;
   long dtype=(long)HistoryDealGetInteger(trans.deal, DEAL_TYPE);
   long dentry=(long)HistoryDealGetInteger(trans.deal, DEAL_ENTRY);
   if(dtype==DEAL_TYPE_BALANCE) return;

   // loss → cooldown markers
   double profit=(double)HistoryDealGetDouble(trans.deal, DEAL_PROFIT);
   if(dentry==DEAL_ENTRY_OUT)
   {
      // Compute incremental R using baseline money risk and partial volume ratio
      double dealVol = HistoryDealGetDouble(trans.deal, DEAL_VOLUME);
      double Rinc = 0.0;
      if(g_currInitVol>0.0 && g_currMoneyRisk>0.0)
      {
         double volRatio = dealVol / g_currInitVol;
         double moneyRiskPart = g_currMoneyRisk * volRatio;
         if(moneyRiskPart>0.0) Rinc = profit / moneyRiskPart;
      }
      g_dayR += Rinc;

      if(profit<0.0)
      {
         g_lastLossTime=(datetime)HistoryDealGetInteger(trans.deal, DEAL_TIME);
         g_lastLossBar =iBars(_Symbol, InpTF);
         g_consecLoss++;
         if(InpDebugLogs) PrintFormat("[V10] Loss detected → cooldown. dayR=%.2fR, consec=%d", g_dayR, g_consecLoss);
      }
      else
      {
         if(g_consecLoss>0) g_consecLoss=0;
      }
      JWrite("EXIT_DEAL", g_currDir, 0,0,0, dealVol, g_currRiskPts, g_currMoneyRisk, profit, Rinc, "");
   }

   // On full close → reset current baseline
   if(PositionSelect(_Symbol)==false)
   {
      g_currTicket=0; g_currRiskPts=0.0; g_currEntry=0.0; g_currInitVol=0.0; g_currMoneyRisk=0.0; g_currDir=0;
   }
}

//======================== Main Tick ==================================
void OnTick()
{
   if(DrawdownExceeded()) return;
   if(CooldownActive())   return;
   if(IsIndecisionZone()) return;
   if(SpreadTooWide())    return;
   if(ATRSpike())         return;
   if(IsTradeBlocked())   return;

   bool up   = TrendUp();
   bool down = TrendDown();

   // --- Pending retest state
   if(g_waitRetest)
   {
      int barsNow = iBars(_Symbol, InpTF);

      if(InpEnableCounterFB && DetectFalseBreak(g_breakUp, g_breakLevel, InpFalseBreakWindow))
      {
         double e=0,s=0,sp=0, atrp=ATRpts(InpTF, InpATR);
         if(atrp>0)
         {
            if(g_breakUp) { e=SymbolInfoDouble(_Symbol,SYMBOL_BID); sp=atrp*1.2; s=e + PipsToPrice(sp);
                            SetRiskOnce(PickRisk(false,true));
                            double tp=(InpUseTP1_BE_Trail?0.0:(e - PipsToPrice(sp*2.0)));
                            if(OpenPosition(-1,e,s,tp)){ g_waitRetest=false; ManageOpenPositions(); return; } }
            else          { e=SymbolInfoDouble(_Symbol,SYMBOL_ASK); sp=atrp*1.2; s=e - PipsToPrice(sp);
                            SetRiskOnce(PickRisk(false,true));
                            double tp=(InpUseTP1_BE_Trail?0.0:(e + PipsToPrice(sp*2.0)));
                            if(OpenPosition(1,e,s,tp)){ g_waitRetest=false; ManageOpenPositions(); return; } }
         }
      }

      if(barsNow - g_breakBar > InpRetestTTLBars) { g_waitRetest=false; }
      else {
         double e=0,s=0,sp=0;
         if(RetestReadyNow(g_breakUp, g_breakLevel, e, s, sp))
         {
            SetRiskOnce(PickRisk(true,false));
            double tp = (InpUseTP1_BE_Trail ? 0.0
                       : (g_breakUp ? (e + PipsToPrice(sp*2.0))
                                    : (e - PipsToPrice(sp*2.0))));
            if(OpenPosition(g_breakUp?1:-1, e, s, tp)){ g_waitRetest=false; ManageOpenPositions(); return; }
         }
      }
   }

   // --- Range mode
   if(InpEnableRangeMode)
   {
      double U=0,L=0; int tU=0,tD=0;
      if(DetectRange(U,L,tU,tD))
      {
         double atrp=ATRpts(InpTF, InpATR);
         if(InpLongs && (InpRangeIgnoreEMA || up) && !HasOpenPositionDir(1))
         {
            double e=0,s=0,sp=0;
            if(RangeSignalBuy(U,L,atrp,e,s,sp))
            { SetRiskOnce(PickRisk(false,false));
              double tp=(InpUseTP1_BE_Trail?0.0:(e + PipsToPrice(sp*2.0)));
              if(OpenPosition(1,e,s,tp)){ ManageOpenPositions(); return; } }
         }
         if(InpShorts && (InpRangeIgnoreEMA || down) && !HasOpenPositionDir(-1))
         {
            double e=0,s=0,sp=0;
            if(RangeSignalSell(U,L,atrp,e,s,sp))
            { SetRiskOnce(PickRisk(false,false));
              double tp=(InpUseTP1_BE_Trail?0.0:(e - PipsToPrice(sp*2.0)));
              if(OpenPosition(-1,e,s,tp)){ ManageOpenPositions(); return; } }
         }
      }
   }

   // --- Breakout detect -> state
   if(InpLongs && up && !HasOpenPositionDir(1))
   {
      int sh=0; double lvl=0.0;
      if(BreakoutUp_Q(sh, lvl))
      { g_waitRetest=true; g_breakUp=true;  g_breakLevel=lvl; g_breakBar=iBars(_Symbol, InpTF); }
   }
   if(InpShorts && down && !HasOpenPositionDir(-1))
   {
      int sh=0; double lvl=0.0;
      if(BreakoutDown_Q(sh, lvl))
      { g_waitRetest=true; g_breakUp=false; g_breakLevel=lvl; g_breakBar=iBars(_Symbol, InpTF); }
   }

   // --- Pullback continuation (Micro EMA50)
   if(!g_waitRetest)
   {
      double atrp=ATRpts(InpTF, InpATR);
      if(atrp>0)
      {
         if(InpLongs && up && !HasOpenPositionDir(1))
         {
            double ema=EMA(InpTFMicro, InpEMAMicro, 0);
            double tol=PipsToPrice(atrp*InpPB_NearEMAAtr);
            double h=iHigh(_Symbol, InpTF, 0), l=iLow(_Symbol, InpTF, 0),
                   o=iOpen(_Symbol, InpTF, 0), c=iClose(_Symbol, InpTF, 0);
            bool near=(MathAbs(c-ema)<=tol)||(l<=ema+tol);
            double range=h-l; if(range>0)
            {
               double lowerW=(MathMin(o,c)-l);
               double wickPct=(lowerW/range)*100.0;
               if(near && c>=o && wickPct>=InpPB_WickMinPct)
               {
                  double e=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
                  double sp=atrp*1.3; double s=e-PipsToPrice(sp);
                  SetRiskOnce(PickRisk(true,false));
                  double tp=(InpUseTP1_BE_Trail?0.0:(e + PipsToPrice(sp*2.0)));
                  if(OpenPosition(1,e,s,tp)){ ManageOpenPositions(); return; }
               }
            }
         }
         if(InpShorts && down && !HasOpenPositionDir(-1))
         {
            double ema=EMA(InpTFMicro, InpEMAMicro, 0);
            double tol=PipsToPrice(atrp*InpPB_NearEMAAtr);
            double h=iHigh(_Symbol, InpTF, 0), l=iLow(_Symbol, InpTF, 0),
                   o=iOpen(_Symbol, InpTF, 0), c=iClose(_Symbol, InpTF, 0);
            bool near=(MathAbs(c-ema)<=tol)||(h>=ema-tol);
            double range=h-l; if(range>0)
            {
               double upperW=(h-MathMax(o,c));
               double wickPct=(upperW/range)*100.0;
               if(near && c<=o && wickPct>=InpPB_WickMinPct)
               {
                  double e=SymbolInfoDouble(_Symbol,SYMBOL_BID);
                  double sp=atrp*1.3; double s=e+PipsToPrice(sp);
                  SetRiskOnce(PickRisk(true,false));
                  double tp=(InpUseTP1_BE_Trail?0.0:(e - PipsToPrice(sp*2.0)));
                  if(OpenPosition(-1,e,s,tp)){ ManageOpenPositions(); return; }
               }
            }
         }
      }
   }

   // --- HUD/Logs
   if(InpDebugLogs && NewBar())
   {
      string msg=StringFormat("UP:%d DN:%d wait:%d lvl:%.5f TTL:%d  indec:%d  dayR=%.2fR consec=%d",
         (int)up,(int)down,(int)g_waitRetest,g_breakLevel,(g_waitRetest? iBars(_Symbol,InpTF)-g_breakBar:0),
         (int)IsIndecisionZone(), g_dayR, g_consecLoss);
      Print("[V10] ", msg);
      HUD("V10  "+msg);
   }

   ManageOpenPositions();
}
//+------------------------------------------------------------------+
