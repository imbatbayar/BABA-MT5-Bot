//+------------------------------------------------------------------+
//|                                                     Hypatia_V8   |
//| SmartTrend+Channel: Macro(H4 EMA200) + Micro(H1 EMA50) filter    |
//| Breakout→Retest state, Fakeout counter (opt), Pullback fallback  |
//| Risk 1% trend / 0.5% range (dynamic), TP1 1R 50%→BE→ATR trail    |
//+------------------------------------------------------------------+
#property strict

//=== Inputs: General
input ENUM_TIMEFRAMES InpTF        = PERIOD_H1;    // Entry TF
input int             InpMagic     = 880008;       // Magic
input double          InpRiskPct   = 1.0;          // Default risk (% of equity)
input double          InpMaxDDDay  = 5.0;          // Max daily DD (%)
input double          InpMaxDDMon  = 15.0;         // Max monthly DD (%)
input bool            InpLongs     = true;
input bool            InpShorts    = true;

//=== Inputs: Trend / ATR / EMA
input ENUM_TIMEFRAMES InpTFTrend   = PERIOD_H4;    // Macro TF (EMA200)
input int             InpEMA       = 200;
input ENUM_TIMEFRAMES InpTFMicro   = PERIOD_H1;    // Micro TF (EMA50)
input int             InpEMAMicro  = 50;
input int             InpATR       = 14;

//=== Inputs: Breakout+Retest (quality-first)
input int    InpSRLookback        = 80;            // bars to scan S/R
input int    InpMinTouches        = 2;             // min touches for level
input int    InpMaxBarsRetest     = 6;             // legacy retest window
input int    InpConfirmBodyPct    = 45;            // breakout body %
input double InpBreakBuffATR      = 0.25;          // breakout close buffer (×ATR)
input double InpRetestTolATR      = 0.5;           // retest touch tol (×ATR)
input double InpRetestWickMinPct  = 35.0;          // wick% toward trend on retest

//=== Inputs: Cooldown after loss
input int    InpCooldownBars      = 6;             // bars
input int    InpCooldownMinutes   = 0;             // minutes

//=== Inputs: Position mgmt
input bool   InpUseTP1_BE_Trail   = true;
input double InpRR_TP1            = 1.0;           // first partial at 1R
input double InpTrailATRmult      = 2.0;           // ATR multiple for trailing

//=== Inputs: Range/Channel & Indecision filters
input bool   InpEnableRangeMode       = true;   // Trade inside channels
input int    InpRangeLookback         = 60;     // bars to define channel
input double InpRangeMinWidthATR      = 1.0;    // min channel width (×ATR)
input double InpRangeSlopeATRPerBar   = 0.08;   // |slope| < this (ATR/bar) -> range
input int    InpRangeMinTouches       = 2;      // touches per side
input double InpRangeTouchTolATR      = 0.30;   // touch tolerance (×ATR)
input bool   InpRangeIgnoreEMA        = true;   // allow counter-EMA trades in range

input bool   InpSkipIndecision        = true;   // skip chop zones
input int    InpIndecN                = 5;      // last N candles
input double InpIndecBodyPctMax       = 25.0;   // small body %
input double InpIndecRangeATR         = 0.60;   // small range (<×ATR)

//=== Inputs: V8 Smart Trend, Risk & State
input bool   InpUseDynamicRisk     = true;
input double InpRiskTrendPct       = 1.0;   // Strong trend / breakout risk
input double InpRiskRangePct       = 0.5;   // Inside channel risk
input double InpRiskCounterPct     = 0.4;   // Counter-trade on fakeout

// Retest state
input int    InpRetestTTLBars      = 8;     // Wait up to N bars for retest
input int    InpFalseBreakWindow   = 2;     // Bars to consider fakeout after breakout
input bool   InpEnableCounterFB    = true;  // Trade opposite on fakeout

// Pullback continuation (EMA50 on Micro TF)
input double InpPB_NearEMAAtr      = 0.30;  // distance to EMA ≤ ATR×X
input double InpPB_WickMinPct      = 30.0;  // lower/upper wick% toward trend

//=== Global state
datetime g_lastLossTime = 0;
int      g_lastLossBar  = -1;

double   g_point, g_tickvalue;
int      g_digits;

// Retest/breakout state
bool   g_waitRetest = false;
bool   g_breakUp    = false;
double g_breakLevel = 0.0;
int    g_breakBar   = -1;

// one-shot risk override
double g_riskOverridePct = -1.0;

//=== Forward declarations
double  EMA(ENUM_TIMEFRAMES tf, int period, int shift=0);
double  ATRpts(ENUM_TIMEFRAMES tf, int period, int shift=0);
double  PipsToPrice(double pips);
bool    AllowedSession();
bool    DrawdownExceeded();

bool    MacroTrendUp();
bool    MacroTrendDown();
bool    MicroTrendUp();
bool    MicroTrendDown();
bool    TrendUp();
bool    TrendDown();

bool    IsIndecisionZone();

bool    DetectRange(double &upper, double &lower, int &touchUp, int &touchDn);
bool    RangeSignalBuy(double upper, double lower, double atr_pts,
                       double &entryPrice, double &slPrice, double &slPts);
bool    RangeSignalSell(double upper, double lower, double atr_pts,
                        double &entryPrice, double &slPrice, double &slPts);

bool    FindLevelUp(double &level_price, int &touches);
bool    FindLevelDown(double &level_price, int &touches);
bool    BreakoutUp_Q(int &breakShift, double &level_price);
bool    BreakoutDown_Q(int &breakShift, double &level_price);
bool    RetestReadyNow(bool up, double level_price,
                       double &entryPrice, double &slPrice, double &slPts);
bool    DetectFalseBreak(bool up, double level, int window);

bool    HasOpenPosition(int dir);
bool    OpenPosition(int dir, double entry, double sl, double tp);
double  LotsForRisk(double sl_points);
bool    ClosePartial(ulong ticket, double frac);
bool    MoveSLtoBE(ulong ticket, double entry_price);
bool    UpdateATRTrail(ulong ticket, double atr_pts, double entry);
void    ManageOpenPositions();

void    SetRiskOnce(double pct);
double  PickRisk(bool trendMode, bool counterMode=false);

//=== Impl
double PipsToPrice(double pips){ return pips * g_point; }

int OnInit()
{
   g_point     = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   g_tickvalue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   g_digits    = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);

   g_lastLossTime = 0;
   g_lastLossBar  = iBars(_Symbol, InpTF);

   Print("Hypatia_V8 init OK");
   return(INIT_SUCCEEDED);
}
void OnDeinit(const int reason){ Print("Hypatia_V8 deinit. reason=", reason); }

bool AllowedSession(){ return true; } // TODO: session/news filter if needed
bool DrawdownExceeded(){ return false; } // TODO: snapshots

//--- EMA value
double EMA(ENUM_TIMEFRAMES tf, int period, int shift)
{
   int handle = iMA(_Symbol, tf, period, 0, MODE_EMA, PRICE_CLOSE);
   if(handle==INVALID_HANDLE) return 0.0;
   double buf[]; if(CopyBuffer(handle, 0, shift, 1, buf)<1) return 0.0;
   return buf[0];
}

//--- ATR in points
double ATRpts(ENUM_TIMEFRAMES tf, int period, int shift)
{
   int handle = iATR(_Symbol, tf, period);
   if(handle==INVALID_HANDLE) return 0.0;
   double buf[]; if(CopyBuffer(handle, 0, shift, 1, buf)<1) return 0.0;
   return buf[0]/_Point; // points
}

//--- Candle body % (generic TF)
double BodyPctTF(ENUM_TIMEFRAMES tf, int shift)
{
   MqlRates r[]; if(CopyRates(_Symbol, tf, shift, 2, r)<2) return 0.0;
   double body=MathAbs(r[0].close-r[0].open), range=(r[0].high-r[0].low);
   if(range<=0) return 0.0;
   return (body/range)*100.0;
}

//--- Indecision/chop filter
bool IsIndecisionZone()
{
   if(!InpSkipIndecision) return false;
   double atrp = ATRpts(InpTF, InpATR); if(atrp<=0) return false;

   int n = MathMax(3, InpIndecN);
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, n, r) < n) return false;

   int smallCnt = 0;
   for(int i=0;i<n;i++)
   {
      double body = MathAbs(r[i].close - r[i].open);
      double range= (r[i].high  - r[i].low);
      double bodyPct = (range>0 ? (body/range)*100.0 : 0.0);
      bool smallBody = (bodyPct <= InpIndecBodyPctMax);
      bool smallRange= ((range/_Point) <= atrp*InpIndecRangeATR);
      if(smallBody && smallRange) smallCnt++;
   }
   return (smallCnt >= (n*3)/5); // ≥60% жижиг => indecision
}

//--- Macro/Micro trends
bool MacroTrendUp()   { return (SymbolInfoDouble(_Symbol,SYMBOL_BID) > EMA(InpTFTrend, InpEMA, 0)); }
bool MacroTrendDown() { return (SymbolInfoDouble(_Symbol,SYMBOL_ASK) < EMA(InpTFTrend, InpEMA, 0)); }
bool MicroTrendUp()   { return (iClose(_Symbol, InpTFMicro, 0)      > EMA(InpTFMicro, InpEMAMicro, 0)); }
bool MicroTrendDown() { return (iClose(_Symbol, InpTFMicro, 0)      < EMA(InpTFMicro, InpEMAMicro, 0)); }

bool TrendUp()  { return MacroTrendUp()  && MicroTrendUp();  }
bool TrendDown(){ return MacroTrendDown()&& MicroTrendDown();}

//--- Detect horizontal channel (range)
bool DetectRange(double &upper, double &lower, int &touchUp, int &touchDn)
{
   upper=0.0; lower=0.0; touchUp=0; touchDn=0;

   int need = InpRangeLookback + 5;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, need, r) < InpRangeLookback) return false;

   double atrp = ATRpts(InpTF, InpATR); if(atrp<=0) return false;

   double hi=r[1].high, lo=r[1].low;
   for(int i=1;i<=InpRangeLookback;i++){ hi=MathMax(hi, r[i].high); lo=MathMin(lo, r[i].low); }

   double widthPts = (hi - lo)/_Point;
   if(widthPts < atrp*InpRangeMinWidthATR) return false;

   // slope (points/bar)
   double slopePtsPerBar = MathAbs((r[0].close - r[InpRangeLookback].close)/_Point) / InpRangeLookback;
   if(slopePtsPerBar > atrp*InpRangeSlopeATRPerBar) return false; // trending too much

   // count touches near edges
   double tol = atrp*InpRangeTouchTolATR;
   for(int i=1;i<=InpRangeLookback;i++)
   {
      if(MathAbs((r[i].high/_Point) - (hi/_Point)) <= tol) touchUp++;
      if(MathAbs((r[i].low/_Point)  - (lo/_Point)) <= tol) touchDn++;
   }
   if(touchUp < InpRangeMinTouches || touchDn < InpRangeMinTouches) return false;

   upper = hi; lower = lo;
   return true;
}

//--- Range buy near lower bound
bool RangeSignalBuy(double upper, double lower, double atr_pts,
                    double &entryPrice, double &slPrice, double &slPts)
{
   double tol = atr_pts*InpRangeTouchTolATR;
   double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if( ((price/_Point) - (lower/_Point)) > tol ) return false;

   double bodyPct = BodyPctTF(InpTF, 0);
   if(bodyPct < 20.0) return false;

   entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   slPts  = atr_pts*1.0;
   slPrice= entryPrice - PipsToPrice(slPts);
   return true;
}

//--- Range sell near upper bound
bool RangeSignalSell(double upper, double lower, double atr_pts,
                     double &entryPrice, double &slPrice, double &slPts)
{
   double tol = atr_pts*InpRangeTouchTolATR;
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   if( ((upper/_Point) - (price/_Point)) > tol ) return false;

   double bodyPct = BodyPctTF(InpTF, 0);
   if(bodyPct < 20.0) return false;

   entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   slPts  = atr_pts*1.0;
   slPrice= entryPrice + PipsToPrice(slPts);
   return true;
}

//=== Level detection by swing clustering
bool FindLevelUp(double &level_price, int &touches)
{
   level_price=0.0; touches=0;
   int need=InpSRLookback+5;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, need, r)<need/2) return false;

   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   double tol_pts=atrp*0.25;

   double candidates[256]; int csz=0;
   int n=ArraySize(r);
   for(int i=1;i<n-1 && csz<256;i++)
      if(r[i].high>r[i-1].high && r[i].high>r[i+1].high)
         candidates[csz++]=r[i].high/_Point;

   if(csz==0) return false;

   int bestTouch=0; double bestLevelPts=0.0;
   for(int k=0;k<csz;k++)
   {
      double lvl=candidates[k]; int t=0;
      for(int j=1;j<n;j++)
         if(MathAbs((r[j].high/_Point)-lvl)<=tol_pts) t++;
      if(t>=InpMinTouches && (t>bestTouch || (t==bestTouch && lvl>bestLevelPts)))
      { bestTouch=t; bestLevelPts=lvl; }
   }
   if(bestTouch<InpMinTouches) return false;

   level_price=bestLevelPts*_Point;
   touches=bestTouch; return true;
}

bool FindLevelDown(double &level_price, int &touches)
{
   level_price=0.0; touches=0;
   int need=InpSRLookback+5;
   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, need, r)<need/2) return false;

   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   double tol_pts=atrp*0.25;

   double candidates[256]; int csz=0;
   int n=ArraySize(r);
   for(int i=1;i<n-1 && csz<256;i++)
      if(r[i].low<r[i-1].low && r[i].low<r[i+1].low)
         candidates[csz++]=r[i].low/_Point;

   if(csz==0) return false;

   int bestTouch=0; double bestLevelPts=0.0;
   for(int k=0;k<csz;k++)
   {
      double lvl=candidates[k]; int t=0;
      for(int j=1;j<n;j++)
         if(MathAbs((r[j].low/_Point)-lvl)<=tol_pts) t++;
      if(t>=InpMinTouches && (t>bestTouch || (t==bestTouch && lvl<bestLevelPts)))
      { bestTouch=t; bestLevelPts=lvl; }
   }
   if(bestTouch<InpMinTouches) return false;

   level_price=bestLevelPts*_Point;
   touches=bestTouch; return true;
}

//=== Breakout checks (quality-first)
bool BreakoutUp_Q(int &breakShift, double &level_price)
{
   int touch=0;
   if(!FindLevelUp(level_price, touch)) return false;

   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   MqlRates rr[]; if(CopyRates(_Symbol, InpTF, 0, 1, rr)<1) return false;
   double close0=rr[0].close;

   if(BodyPctTF(InpTF,0) < InpConfirmBodyPct) return false;
   if( (close0 - level_price) < PipsToPrice(atrp*InpBreakBuffATR) ) return false;

   breakShift=0; return true;
}
bool BreakoutDown_Q(int &breakShift, double &level_price)
{
   int touch=0;
   if(!FindLevelDown(level_price, touch)) return false;

   double atrp=ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   MqlRates rr[]; if(CopyRates(_Symbol, InpTF, 0, 1, rr)<1) return false;
   double close0=rr[0].close;

   if(BodyPctTF(InpTF,0) < InpConfirmBodyPct) return false;
   if( (level_price - close0) < PipsToPrice(atrp*InpBreakBuffATR) ) return false;

   breakShift=0; return true;
}

//=== Retest on current bar after breakout (wick + direction + wick%)
bool RetestReadyNow(bool up, double level_price,
                    double &entryPrice, double &slPrice, double &slPts)
{
   double atrp = ATRpts(InpTF, InpATR); if(atrp<=0) return false;
   double tol  = atrp*InpRetestTolATR;

   MqlRates r[]; if(CopyRates(_Symbol, InpTF, 0, 2, r)<2) return false;
   double h=r[0].high, l=r[0].low, o=r[0].open, c=r[0].close;

   bool touched = up ? (MathAbs((level_price/_Point)-(l/_Point))<=tol)
                     : (MathAbs((level_price/_Point)-(h/_Point))<=tol);
   double range=h-l; if(range<=0) return false;
   double upperW=h-MathMax(o,c), lowerW=MathMin(o,c)-l;
   double wickPct = (up ? (lowerW/range) : (upperW/range))*100.0;
   bool dirOK   = up ? (c>=o) : (c<=o);

   if(!(touched && dirOK && wickPct>=InpRetestWickMinPct)) return false;

   if(up){ entryPrice=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
           slPts=atrp*1.2; slPrice=entryPrice-PipsToPrice(slPts); }
   else  { entryPrice=SymbolInfoDouble(_Symbol,SYMBOL_BID);
           slPts=atrp*1.2; slPrice=entryPrice+PipsToPrice(slPts); }
   return true;
}

//=== False-break detect (close back across level within window)
bool DetectFalseBreak(bool up, double level, int window)
{
   for(int i=1;i<=window;i++){
      double c=iClose(_Symbol, InpTF, i);
      if(up && c<level)  return true;
      if(!up && c>level) return true;
   }
   return false;
}

//=== Dynamic risk helpers
void SetRiskOnce(double pct){ g_riskOverridePct = pct; }
double PickRisk(bool trendMode, bool counterMode)
{
   if(!InpUseDynamicRisk) return InpRiskPct;
   if(counterMode) return InpRiskCounterPct;
   return (trendMode ? InpRiskTrendPct : InpRiskRangePct);
}

//=== Risk sizing (uses one-shot override if set)
double LotsForRisk(double sl_points)
{
   if(sl_points<=0.0) return 0.0;
   double equity=AccountInfoDouble(ACCOUNT_EQUITY);

   double useRiskPct = (g_riskOverridePct>0.0 ? g_riskOverridePct : InpRiskPct);
   double riskUSD=equity*(useRiskPct/100.0);

   double tvpp=g_tickvalue/(1.0/g_point); // tick value per point

   double step=SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot=SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot=SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   double lots=riskUSD/(sl_points*tvpp);
   lots=MathFloor(lots/step)*step;
   lots=MathMax(minLot, MathMin(maxLot, lots));

   g_riskOverridePct = -1.0; // reset override
   return lots;
}

//=== Netting: one position per symbol by magic & dir
bool HasOpenPosition(int dir /*1 buy, -1 sell*/)
{
   if(!PositionSelect(_Symbol)) return false;
   if(PositionGetInteger(POSITION_MAGIC)!=InpMagic) return false;
   long type=PositionGetInteger(POSITION_TYPE);
   if(dir==1  && type==POSITION_TYPE_BUY ) return true;
   if(dir==-1 && type==POSITION_TYPE_SELL) return true;
   return false;
}

//--- Partial close
bool ClosePartial(ulong ticket, double frac)
{
   if(!PositionSelectByTicket(ticket)) return false;
   double vol=PositionGetDouble(POSITION_VOLUME);
   double step=SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double part=MathFloor(vol*frac/step)*step;
   if(part<=0) return false;

   long posType=PositionGetInteger(POSITION_TYPE);
   ENUM_ORDER_TYPE orderType=(posType==POSITION_TYPE_BUY)? ORDER_TYPE_SELL:ORDER_TYPE_BUY;
   double px=(orderType==ORDER_TYPE_SELL)? SymbolInfoDouble(_Symbol,SYMBOL_BID)
                                         : SymbolInfoDouble(_Symbol,SYMBOL_ASK);

   MqlTradeRequest req; ZeroMemory(req);
   MqlTradeResult  res; ZeroMemory(res);
   req.action=TRADE_ACTION_DEAL; req.magic=InpMagic; req.symbol=_Symbol;
   req.deviation=20; req.type=orderType; req.volume=part; req.price=px;

   bool ok=OrderSend(req,res);
   if(!ok) Print("Partial close failed: ", _LastError);
   return ok;
}

//--- BE move
bool MoveSLtoBE(ulong ticket, double entry_price)
{
   if(!PositionSelectByTicket(ticket)) return false;
   double curSL=PositionGetDouble(POSITION_SL);
   long   type =PositionGetInteger(POSITION_TYPE);
   double be=entry_price;

   if(curSL==0 || (type==POSITION_TYPE_BUY && curSL<be) || (type==POSITION_TYPE_SELL && curSL>be))
   {
      MqlTradeRequest req; ZeroMemory(req);
      MqlTradeResult  res; ZeroMemory(res);
      req.action=TRADE_ACTION_SLTP; req.magic=InpMagic; req.symbol=_Symbol;
      req.sl=be; req.tp=PositionGetDouble(POSITION_TP);
      bool ok=OrderSend(req,res);
      if(!ok) Print("BE move failed: ", _LastError);
      return ok;
   }
   return true;
}

//--- ATR trail
bool UpdateATRTrail(ulong ticket, double atr_pts, double entry)
{
   if(!PositionSelectByTicket(ticket)) return false;
   long type=PositionGetInteger(POSITION_TYPE);
   double price=(type==POSITION_TYPE_BUY)? SymbolInfoDouble(_Symbol,SYMBOL_BID)
                                         : SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double trailPts=atr_pts*InpTrailATRmult;
   double newSL;

   if(type==POSITION_TYPE_BUY)
   {
      newSL=price - PipsToPrice(trailPts);
      if(newSL>PositionGetDouble(POSITION_SL))
      {
         MqlTradeRequest req; ZeroMemory(req);
         MqlTradeResult  res; ZeroMemory(res);
         req.action=TRADE_ACTION_SLTP; req.magic=InpMagic; req.symbol=_Symbol;
         req.sl=newSL; req.tp=PositionGetDouble(POSITION_TP);
         return OrderSend(req,res);
      }
   }
   else
   {
      newSL=price + PipsToPrice(trailPts);
      if(newSL<PositionGetDouble(POSITION_SL))
      {
         MqlTradeRequest req; ZeroMemory(req);
         MqlTradeResult  res; ZeroMemory(res);
         req.action=TRADE_ACTION_SLTP; req.magic=InpMagic; req.symbol=_Symbol;
         req.sl=newSL; req.tp=PositionGetDouble(POSITION_TP);
         return OrderSend(req,res);
      }
   }
   return true;
}

//--- Order open
bool OpenPosition(int dir, double entry, double sl, double tp /*0 if managed*/)
{
   double slPts=MathAbs((entry-sl)/g_point);
   double lots=LotsForRisk(slPts);
   if(lots<=0){ Print("Lots calc <=0"); return false; }

   MqlTradeRequest req; ZeroMemory(req);
   MqlTradeResult  res; ZeroMemory(res);
   req.action=TRADE_ACTION_DEAL; req.magic=InpMagic; req.symbol=_Symbol;
   req.deviation=20; req.volume=lots;

   if(dir==1){ req.type=ORDER_TYPE_BUY;  req.price=SymbolInfoDouble(_Symbol,SYMBOL_ASK); }
   else      { req.type=ORDER_TYPE_SELL; req.price=SymbolInfoDouble(_Symbol,SYMBOL_BID); }

   req.sl=sl; req.tp=tp;
   bool ok=OrderSend(req,res);
   if(!ok) Print("OrderSend fail: ", _LastError);
   return ok;
}

//=== Position management
void ManageOpenPositions()
{
   if(!InpUseTP1_BE_Trail) return;
   if(!PositionSelect(_Symbol)) return;
   if(PositionGetInteger(POSITION_MAGIC)!=InpMagic) return;

   ulong  t    =(ulong)PositionGetInteger(POSITION_TICKET);
   long   type =PositionGetInteger(POSITION_TYPE);
   double entry=PositionGetDouble(POSITION_PRICE_OPEN);
   double sl   =PositionGetDouble(POSITION_SL);

   double priceBid=SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double priceAsk=SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double price=(type==POSITION_TYPE_BUY)? priceBid:priceAsk;

   double riskPts=MathAbs((entry-sl)/g_point);
   if(riskPts<=0) return;

   double rrNowPts = (type==POSITION_TYPE_BUY)? (price-entry)/g_point : (entry-price)/g_point;

   // TP1 at 1R -> 50% close + BE
   if(rrNowPts >= (InpRR_TP1 * riskPts))
   {
      ClosePartial(t, 0.5);
      MoveSLtoBE(t, entry);
   }

   // trail
   double atrp=ATRpts(InpTF, InpATR);
   UpdateATRTrail(t, atrp, entry);
}

//=== Cooldown on loss
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(trans.type!=TRADE_TRANSACTION_DEAL_ADD) return;
   long dtype=(long)HistoryDealGetInteger(trans.deal, DEAL_TYPE);
   long dentry=(long)HistoryDealGetInteger(trans.deal, DEAL_ENTRY);
   if(dtype==DEAL_TYPE_BALANCE) return;

   double profit=(double)HistoryDealGetDouble(trans.deal, DEAL_PROFIT);
   if(dentry==DEAL_ENTRY_OUT && profit<0.0)
   {
      g_lastLossTime=(datetime)HistoryDealGetInteger(trans.deal, DEAL_TIME);
      g_lastLossBar =iBars(_Symbol, InpTF);
      Print("Loss detected -> cooldown armed. time=", TimeToString(g_lastLossTime));
   }
}

//=== TICK: SmartTrend + Channel + State machine
void OnTick()
{
   if(!AllowedSession()) return;
   if(DrawdownExceeded()) return;
   if(CooldownActive())   return;
   if(IsIndecisionZone()) return;

   bool up   = TrendUp();
   bool down = TrendDown();

   // 0) Pending RE-TEST state first
   if(g_waitRetest)
   {
      int barsNow = iBars(_Symbol, InpTF);

      // 0.1) Fakeout? — opposite trade (small risk)
      if(InpEnableCounterFB && DetectFalseBreak(g_breakUp, g_breakLevel, InpFalseBreakWindow))
      {
         double e=0,s=0,sp=0, atrp=ATRpts(InpTF, InpATR);
         if(atrp>0)
         {
            if(g_breakUp) { // counter SELL
               e=SymbolInfoDouble(_Symbol,SYMBOL_BID);
               sp=atrp*1.2; s=e + PipsToPrice(sp);
               SetRiskOnce(PickRisk(false,true));
               double tp=(InpUseTP1_BE_Trail?0.0:(e - PipsToPrice(sp*2.0)));
               if(OpenPosition(-1,e,s,tp)){ g_waitRetest=false; ManageOpenPositions(); return; }
            } else {         // counter BUY
               e=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
               sp=atrp*1.2; s=e - PipsToPrice(sp);
               SetRiskOnce(PickRisk(false,true));
               double tp=(InpUseTP1_BE_Trail?0.0:(e + PipsToPrice(sp*2.0)));
               if(OpenPosition(1,e,s,tp)){ g_waitRetest=false; ManageOpenPositions(); return; }
            }
         }
      }

      // 0.2) TTL over?
      if(barsNow - g_breakBar > InpRetestTTLBars) { g_waitRetest=false; }
      else
      {
         double e=0,s=0,sp=0;
         if(RetestReadyNow(g_breakUp, g_breakLevel, e, s, sp))
         {
            SetRiskOnce(PickRisk(true,false));
            double tp = (InpUseTP1_BE_Trail ? 0.0
                       : (g_breakUp ? (e + PipsToPrice(sp*2.0))
                                    : (e - PipsToPrice(sp*2.0))));
            if(OpenPosition(g_breakUp?1:-1, e, s, tp)){ g_waitRetest=false; ManageOpenPositions(); return; }
         }
      }
   }

   // 1) RANGE mode
   if(InpEnableRangeMode)
   {
      double upper=0.0, lower=0.0; int tU=0,tD=0;
      if(DetectRange(upper, lower, tU, tD))
      {
         double atrp = ATRpts(InpTF, InpATR);
         if(InpLongs && (InpRangeIgnoreEMA || up) && !HasOpenPosition(1))
         {
            double e=0,s=0,sp=0;
            if(RangeSignalBuy(upper, lower, atrp, e, s, sp))
            {
               SetRiskOnce(PickRisk(false,false));
               double tp = (InpUseTP1_BE_Trail ? 0.0 : (e + PipsToPrice(sp*2.0)));
               if(OpenPosition(1, e, s, tp)){ ManageOpenPositions(); return; }
            }
         }
         if(InpShorts && (InpRangeIgnoreEMA || down) && !HasOpenPosition(-1))
         {
            double e=0,s=0,sp=0;
            if(RangeSignalSell(upper, lower, atrp, e, s, sp))
            {
               SetRiskOnce(PickRisk(false,false));
               double tp = (InpUseTP1_BE_Trail ? 0.0 : (e - PipsToPrice(sp*2.0)));
               if(OpenPosition(-1, e, s, tp)){ ManageOpenPositions(); return; }
            }
         }
      }
   }

   // 2) BREAKOUT detect → save state (no immediate entry)
   if(InpLongs && up && !HasOpenPosition(1))
   {
      int sh=0; double lvl=0.0;
      if(BreakoutUp_Q(sh, lvl))
      { g_waitRetest=true; g_breakUp=true;  g_breakLevel=lvl; g_breakBar=iBars(_Symbol, InpTF); return; }
   }
   if(InpShorts && down && !HasOpenPosition(-1))
   {
      int sh=0; double lvl=0.0;
      if(BreakoutDown_Q(sh, lvl))
      { g_waitRetest=true; g_breakUp=false; g_breakLevel=lvl; g_breakBar=iBars(_Symbol, InpTF); return; }
   }

   // 3) Trend-continuation fallback (Micro EMA50 pullback) — only if not waiting retest
   if(!g_waitRetest)
   {
      double atrp=ATRpts(InpTF, InpATR);
      if(atrp>0)
      {
         // BUY pullback
         if(InpLongs && TrendUp() && !HasOpenPosition(1))
         {
            // near EMA on Micro TF + bullish wick
            double ema  = EMA(InpTFMicro, InpEMAMicro, 0);
            double tolP = PipsToPrice(atrp*InpPB_NearEMAAtr);
            double h=iHigh(_Symbol, InpTF, 0), l=iLow(_Symbol, InpTF, 0),
                   o=iOpen(_Symbol, InpTF, 0), c=iClose(_Symbol, InpTF, 0);
            bool near = (MathAbs(c-ema)<=tolP) || (l<=ema+tolP);
            double range=h-l; if(range>0)
            {
               double lowerW=(MathMin(o,c)-l);
               double wickPct=(lowerW/range)*100.0;
               if(near && c>=o && wickPct>=InpPB_WickMinPct)
               {
                  double e=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
                  double sp=atrp*1.3; double s=e - PipsToPrice(sp);
                  SetRiskOnce(PickRisk(true,false));
                  double tp=(InpUseTP1_BE_Trail?0.0:(e + PipsToPrice(sp*2.0)));
                  if(OpenPosition(1,e,s,tp)){ ManageOpenPositions(); return; }
               }
            }
         }
         // SELL pullback
         if(InpShorts && TrendDown() && !HasOpenPosition(-1))
         {
            double ema  = EMA(InpTFMicro, InpEMAMicro, 0);
            double tolP = PipsToPrice(atrp*InpPB_NearEMAAtr);
            double h=iHigh(_Symbol, InpTF, 0), l=iLow(_Symbol, InpTF, 0),
                   o=iOpen(_Symbol, InpTF, 0), c=iClose(_Symbol, InpTF, 0);
            bool near = (MathAbs(c-ema)<=tolP) || (h>=ema-tolP);
            double range=h-l; if(range>0)
            {
               double upperW=(h-MathMax(o,c));
               double wickPct=(upperW/range)*100.0;
               if(near && c<=o && wickPct>=InpPB_WickMinPct)
               {
                  double e=SymbolInfoDouble(_Symbol,SYMBOL_BID);
                  double sp=atrp*1.3; double s=e + PipsToPrice(sp);
                  SetRiskOnce(PickRisk(true,false));
                  double tp=(InpUseTP1_BE_Trail?0.0:(e - PipsToPrice(sp*2.0)));
                  if(OpenPosition(-1,e,s,tp)){ ManageOpenPositions(); return; }
               }
            }
         }
      }
   }

   // 4) Manage
   ManageOpenPositions();
}

//=== Cooldown
bool CooldownActive()
{
   bool useBars=(InpCooldownBars>0), useMins=(InpCooldownMinutes>0);
   if(!useBars && !useMins) return false;

   if(useBars && g_lastLossBar>=0)
   {
      int barsNow=iBars(_Symbol, InpTF);
      if(barsNow - g_lastLossBar < InpCooldownBars) return true;
   }
   if(useMins && g_lastLossTime>0)
   {
      datetime now=TimeCurrent();
      if((now-g_lastLossTime) < (InpCooldownMinutes*60)) return true;
   }
   return false;
}
